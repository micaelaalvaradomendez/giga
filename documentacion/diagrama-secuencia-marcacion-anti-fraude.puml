@startuml Marcacion_Asistencia_Seguridad_Anti_Fraude_GIGA
!define SEQUENCE_DIAGRAM

title Sistema GIGA - Diagrama de Secuencia\nMarcaci√≥n de Asistencia con Seguridad Anti-Fraude\nDetecci√≥n y Registro de Intentos Fraudulentos

' ==============================================================================
' ACTORES Y PARTICIPANTES
' ==============================================================================
actor "üë§ Agente" as agente #E3F2FD
participant "üé® Frontend\n(Asistencia)" as frontend #FFF3E0
participant "‚öôÔ∏è Backend\n(Django API)" as backend #FFEBEE
participant "üîí Sistema\nAnti-Fraude" as seguridad #F3E5F5
participant "üóÑÔ∏è Base de Datos\n(PostgreSQL)" as db #F0F4C3

' ==============================================================================
' CONFIGURACI√ìN DE ESTILOS
' ==============================================================================
skinparam backgroundColor #FFFFFF
skinparam sequenceMessageAlign center
skinparam sequenceReferenceAlign center

' ==============================================================================
' FLUJO 1: AGENTE INGRESA DNI EN LA INTERFAZ
' ==============================================================================
group Inicio del Proceso de Marcaci√≥n

    agente -> frontend : 1. Accede a "/asistencia"
    note right of agente
        **P√°gina de Asistencia:**
        ‚Ä¢ Formulario con campo DNI
        ‚Ä¢ Estado actual (entrada/salida)
        ‚Ä¢ Horario asignado del agente
        ‚Ä¢ Validaci√≥n de d√≠a laborable
    end note
    
    frontend -> backend : GET /api/asistencia/estado/
    note right of frontend
        **Verificaci√≥n Inicial:**
        ‚Ä¢ Obtener estado de asistencia del d√≠a
        ‚Ä¢ Verificar si ya marc√≥ entrada/salida
        ‚Ä¢ Validar si es d√≠a laborable
    end note
    
    backend -> backend : es_dia_laborable(fecha_actual)
    note right of backend
        **Validaci√≥n D√≠a Laborable:**
        1. ‚úÖ No es s√°bado (weekday != 5)
        2. ‚úÖ No es domingo (weekday != 6) 
        3. ‚úÖ No es feriado (Feriado.es_feriado())
    end note
    
    backend -> db : SELECT * FROM feriado WHERE fecha_inicio <= CURRENT_DATE
    db --> backend : feriados_activos[]
    
    backend --> frontend : HTTP 200 + estado_asistencia
    note right of backend
        **Response Estado:**
        {
          "success": true,
          "data": {
            "tiene_entrada": false,
            "tiene_salida": false,
            "puede_marcar_entrada": true,
            "es_dia_laborable": true,
            "motivo_no_laborable": null
          }
        }
    end note
    
    frontend --> agente : üìã Interfaz con estado actual
    note right of frontend
        ‚Ä¢ Vista Agente:
        ‚Ä¢ Estado: "Sin entrada marcada"
        ‚Ä¢ Horario: 08:00 - 16:00
        ‚Ä¢ Campo DNI habilitado
        ‚Ä¢ Bot√≥n "Marcar Asistencia"
    end note

end

' ==============================================================================
' FLUJO 2: CAPTURA DE DNI E IP DEL CLIENTE
' ==============================================================================
group Captura de Datos de Seguridad

    agente -> frontend : 2. Ingresa DNI "12345678" + Click "Marcar"
    note right of agente
        **Datos Ingresados:**
        ‚Ä¢ DNI: "12345678" (incorrecto)
        ‚Ä¢ Usuario logueado: Juan P√©rez
        ‚Ä¢ DNI real del usuario: "87654321"
        ‚Ä¢ IP del cliente: capturada autom√°ticamente
    end note
    
    frontend -> frontend : Capturar datos del cliente
    note right of frontend
        **Captura Autom√°tica:**
        ‚Ä¢ DNI ingresado: del formulario
        ‚Ä¢ IP Address: HTTP headers
        ‚Ä¢ Timestamp: fecha/hora actual
        ‚Ä¢ User Agent: navegador del cliente
        ‚Ä¢ Session ID: de la sesi√≥n activa
    end note
    
    frontend -> backend : POST /api/asistencia/marcar/
    note right of frontend
        **Request Payload:**
        {
          "dni": "12345678",
          "tipo_marcacion": null // auto-detect
        }
        
        **Headers Autom√°ticos:**
        ‚Ä¢ HTTP_X_FORWARDED_FOR: IP real
        ‚Ä¢ HTTP_REMOTE_ADDR: IP del proxy
        ‚Ä¢ HTTP_USER_AGENT: navegador
        ‚Ä¢ Session Cookie: autenticaci√≥n
    end note

end

' ==============================================================================
' FLUJO 3: VALIDACIONES DE SEGURIDAD DEL BACKEND
' ==============================================================================
group Validaciones de Seguridad Anti-Fraude

    backend -> backend : Obtener agente de sesi√≥n activa
    note right of backend
        **Extracci√≥n Sesi√≥n:**
        agente_sesion_id = request.session.get('user_id')
        agente_sesion = Agente.objects.get(id_agente=agente_sesion_id)
        
        **Datos del Usuario:**
        ‚Ä¢ ID: 101 (Juan P√©rez)
        ‚Ä¢ DNI Real: "87654321"
        ‚Ä¢ Rol: "Agente"
    end note
    
    backend -> seguridad : Verificar coincidencia de DNI
    note right of seguridad
        **Validaci√≥n Anti-Fraude:**
        DNI_ingresado: "12345678"
        DNI_usuario_sesion: "87654321"
        
        **Resultado:** ‚ùå NO COINCIDEN
        Detectado intento fraudulento!
    end note
    
    ' CAMINO ALTERNATIVO - FRAUDE DETECTADO
    alt DNI No Coincide (FRAUDE)
        
        seguridad -> backend : ‚ö†Ô∏è Fraude detectado
        
        backend -> backend : get_client_ip(request)
        note right of backend
            **Captura IP Cliente:**
            ‚Ä¢ HTTP_X_FORWARDED_FOR: "192.168.1.100"
            ‚Ä¢ Fallback REMOTE_ADDR: "127.0.0.1"
            ‚Ä¢ IP final: "192.168.1.100"
        end note
        
        backend -> db : BEGIN TRANSACTION (Registro Fraude)
        
        backend -> db : SELECT * FROM agente WHERE dni = '12345678'
        note right of db
            **Buscar Agente del DNI:**
            ‚Ä¢ Verificar si existe agente con DNI ingresado
            ‚Ä¢ Para mayor detalle en auditor√≠a
        end note
        
        db --> backend : agente_dni_objetivo (o null si no existe)
        
        backend -> db : INSERT INTO intento_marcacion_fraudulenta
        note right of db
            **Registro Completo del Intento:**
            INSERT INTO intento_marcacion_fraudulenta (
                fecha, hora, dni_ingresado,
                id_agente_sesion, id_agente_dni,
                tipo_intento, ip_address, creado_en
            ) VALUES (
                CURRENT_DATE, CURRENT_TIME, '12345678',
                101, agente_dni_id, 'entrada_salida',
                '192.168.1.100', NOW()
            )
        end note
        
        db --> backend : intento_id: 501
        
        backend -> db : COMMIT TRANSACTION
        
        backend -> backend : Logging de seguridad
        note right of backend
            **Log de Seguridad:**
            logger.warning(
              'Intento fraudulento: Agente 101 (Juan P√©rez)'
              'intent√≥ usar DNI 12345678 desde IP 192.168.1.100'
            )
        end note
        
        backend --> frontend : HTTP 403 Forbidden
        note right of backend
            **Response Error:**
            {
              "success": false,
              "message": "El DNI ingresado no corresponde a su usuario",
              "tipo": "error_dni",
              "registrado_en_auditoria": true
            }
        end note
        
        frontend --> agente : ‚ùå Error de seguridad + Notificaci√≥n auditor√≠a
        note right of agente
            **Mensaje de Error:**
            "‚ö†Ô∏è El DNI ingresado no corresponde a su usuario - 
            Este intento ha sido registrado en auditor√≠a"
            
            **Efectos:**
            ‚Ä¢ Campo DNI se limpia
            ‚Ä¢ Mensaje de error por 5 segundos
            ‚Ä¢ Intento registrado para revisi√≥n
        end note
        
    ' CAMINO PRINCIPAL - √âXITO
    else DNI Coincide (V√ÅLIDO)
        
        seguridad -> backend : ‚úÖ DNI v√°lido, continuar
        
        backend -> backend : Verificaci√≥n d√≠a laborable
        note right of backend
            **Re-validaci√≥n en Backend:**
            fecha_actual = date.today()
            es_laborable = es_dia_laborable(fecha_actual)
            
            **Si no es laborable:**
            motivo = get_motivo_no_laborable(fecha_actual)
            ‚Ä¢ "s√°bado", "domingo", "feriado (A√±o Nuevo)"
        end note
        
        alt Es D√≠a No Laborable
            backend --> frontend : HTTP 400 Bad Request
            note right of backend
                **Error D√≠a No Laborable:**
                {
                  "success": false,
                  "message": "No se puede registrar asistencia en s√°bado",
                  "tipo": "dia_no_laborable",
                  "motivo": "s√°bado"
                }
            end note
            
            frontend --> agente : üìÖ "No se puede registrar asistencia en s√°bado"
            
        else Es D√≠a Laborable - Proceder con Marcaci√≥n
            
            backend -> db : BEGIN TRANSACTION (Marcaci√≥n V√°lida)
            
            ' Buscar o crear registro de asistencia
            backend -> db : SELECT * FROM asistencia WHERE id_agente=101 AND fecha=CURRENT_DATE
            
            alt Registro Existe
                db --> backend : asistencia_existente
            else Crear Nuevo Registro
                backend -> db : INSERT INTO asistencia (id_agente, fecha, id_area)
                note right of db
                    **Nuevo Registro:**
                    INSERT INTO asistencia (
                        id_agente, fecha, id_area,
                        hora_entrada, hora_salida,
                        creado_en, actualizado_en
                    ) VALUES (
                        101, CURRENT_DATE, 3,
                        NULL, NULL, NOW(), NOW()
                    )
                end note
                
                db --> backend : asistencia_id: 301
            end
            
            ' Determinar tipo de marcaci√≥n
            backend -> backend : L√≥gica de marcaci√≥n autom√°tica
            note right of backend
                **Determinaci√≥n Autom√°tica:**
                if (asistencia.hora_entrada == NULL):
                    tipo = "ENTRADA"
                    hora_entrada = CURRENT_TIME
                elif (asistencia.hora_salida == NULL):
                    tipo = "SALIDA" 
                    hora_salida = CURRENT_TIME
                    calcular_horas_efectivas()
                else:
                    ERROR: "Ya complet√≥ entrada y salida"
            end note
            
            ' Registrar marcaci√≥n de entrada
            backend -> db : UPDATE asistencia SET hora_entrada = CURRENT_TIME
            note right of db
                **Marcaci√≥n Entrada:**
                UPDATE asistencia SET 
                    hora_entrada = '08:15:32',
                    actualizado_en = NOW()
                WHERE id_asistencia = 301
            end note
            
            ' Auditor√≠a de la marcaci√≥n exitosa
            backend -> db : INSERT INTO auditoria
            note right of db
                **Auditor√≠a Marcaci√≥n:**
                INSERT INTO auditoria (
                    pk_afectada, nombre_tabla, accion,
                    valor_previo, valor_nuevo,
                    id_agente, creado_en
                ) VALUES (
                    301, 'asistencia', 'MARCAR_ENTRADA',
                    NULL,
                    '{"hora_entrada": "08:15:32", "agente_dni": "87654321", "marcacion_normal": true}',
                    101, NOW()
                )
            end note
            
            backend -> db : COMMIT TRANSACTION
            
            backend --> frontend : HTTP 200 Success
            note right of backend
                **Response Exitosa:**
                {
                  "success": true,
                  "message": "Entrada registrada a las 08:15",
                  "tipo": "entrada",
                  "data": {
                    "fecha": "2025-11-30",
                    "hora_entrada": "08:15:32",
                    "agente": "Juan P√©rez"
                  }
                }
            end note
            
            frontend --> agente : ‚úÖ "Entrada registrada a las 08:15"
            note right of agente
                **Confirmaci√≥n Visual:**
                ‚Ä¢ Mensaje de √©xito
                ‚Ä¢ Estado actualizado: "Entrada: 08:15"
                ‚Ä¢ Campo DNI se limpia
                ‚Ä¢ Pr√≥xima acci√≥n: "Marcar Salida"
            end note
            
        end
        
    end

end

' ==============================================================================
' EFECTOS Y SEGUIMIENTO DE SEGURIDAD
' ==============================================================================
note over agente, db
    **CARACTER√çSTICAS DEL SISTEMA ANTI-FRAUDE:**
    
    **üîí DETECCI√ìN EN TIEMPO REAL:**
    ‚úÖ Validaci√≥n inmediata DNI vs Usuario de sesi√≥n
    ‚úÖ Captura autom√°tica de IP del cliente
    ‚úÖ Registro completo del intento fraudulento
    ‚úÖ Logging de seguridad para monitoreo
    
    **üìä REGISTRO DETALLADO (tabla: intento_marcacion_fraudulenta):**
    ‚Ä¢ Fecha y hora exacta del intento
    ‚Ä¢ DNI ingresado vs DNI real del usuario
    ‚Ä¢ IP address del cliente (anti-bypass)
    ‚Ä¢ Tipo de intento (entrada/salida)
    ‚Ä¢ Referencias cruzadas entre agentes
    
    **üõ°Ô∏è VALIDACIONES M√öLTIPLES:**
    1. Sesi√≥n activa v√°lida
    2. DNI coincide con usuario logueado
    3. D√≠a laborable (no s√°bados/domingos/feriados)
    4. No duplicar marcaciones del mismo tipo
    5. Horarios l√≥gicos (entrada antes que salida)
    
    **‚ö° FLUJOS DE RESPUESTA:**
    ‚Ä¢ Fraude ‚Üí HTTP 403 + registro en BD + logging
    ‚Ä¢ D√≠a no laborable ‚Üí HTTP 400 + mensaje explicativo  
    ‚Ä¢ √âxito ‚Üí HTTP 200 + c√°lculo autom√°tico de horas
    ‚Ä¢ Duplicado ‚Üí HTTP 400 + estado actual
    
    **üîç AUDITOR√çA COMPLETA:**
    ‚Ä¢ Intentos fraudulentos: tabla espec√≠fica
    ‚Ä¢ Marcaciones exitosas: tabla auditoria general
    ‚Ä¢ Trazabilidad completa por agente y fecha
    ‚Ä¢ Reportes de seguridad disponibles
end note

@enduml